class MyHashSet:
    """
    Open Addressing for handling Collisions
    using Double Hashing to implement
    newIndex = (index1 + i1 * index2) % self.capacity
    """

    def __init__(self, ):
        """
        Initialize your data structure here.
        """
        self.capacity = 1 << 3
        self.load_factor = 0.75
        self.table = [None] * self.capacity
        self.size = 0
        self.prime = 7

    def add(self, key):
        index1 = self.myhash1(key)
        if self.table[index1] == key:
            return

        if self.table[index1] is not None and self.table[index1] != "==TOMBSTONE==":
            index2 = self.myhash2(key)
            i = 1
            while True:
                new_index = (index1 + i * index2) % self.capacity
                if self.table[new_index] == key:
                    return
                if self.table[new_index] is None or self.table[new_index] == "==TOMBSTONE==":
                    self.table[new_index] = key
                    break
                i += 1
        else:
            self.table[index1] = key
        self.size += 1

        if self.size / self.capacity >= self.load_factor:
            self.rehash()

    def remove(self, key):
        index1 = self.myhash1(key)
        if self.table[index1] is not None:
            if self.table[index1] == key:
                self.table[index1] = "==TOMBSTONE=="
                self.size -= 1
                return
            index2 = self.myhash2(key)
            i = 1
            while True:
                new_index = (index1 + i * index2) % self.capacity
                if self.table[new_index] is not None:
                    if self.table[new_index] == key:
                        self.table[new_index] = "==TOMBSTONE=="
                        self.size -= 1
                        return
                    i += 1
                else:
                    return

    def contains(self, key):
        """
        Returns true if this set contains the specified element
        """
        index1 = self.myhash1(key)
        if self.table[index1] == key:
            return True

        if self.table[index1] is not None and self.table[index1] != "==TOMBSTONE==":
            index2 = self.myhash2(key)
            i = 1
            while True:
                new_index = (index1 + i * index2) % self.capacity
                if self.table[new_index] is not None:
                    if self.table[new_index] == key:
                        return True
                    i += 1
                else:
                    return False
        return False

    def myhash1(self, key):
        return key % self.capacity

    def myhash2(self, key):
        return self.prime - key % self.prime

    def rehash(self):
        self.capacity <<= 1
        new_table = [None] * self.capacity
        for i in range(self.capacity >> 1):
            if self.table[i] is not None and self.table[i] != "==TOMBSTONE==":
                index1 = self.myhash1(self.table[i])
                if new_table[index1] is not None:
                    index2 = self.myhash2(self.table[i])
                    i1 = 1
                    while True:
                        new_index = (index1 + i1 * index2) % self.capacity
                        if new_table[new_index] is None:
                            new_table[new_index] = self.table[i]
                            break
                        i1 += 1
                else:
                    new_table[index1] = self.table[i]

        self.table = new_table

    def displayHash(self):
        for i in range(self.capacity):
            print(str(i) + " --> " + str(self.table[i]))
