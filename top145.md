# top145

## 1-Two Sum

将已知数存入hashmap，根据差值在hashmap中查找。O(n)

```python
class Solution:
    def twoSum(self, nums, target):
        map = {}
        for i in range(len(nums)):
            if target - nums[i] in map:
                return map.get(target - nums[i]), i
            map[nums[i]] = i

        raise SyntaxError('No two sum solution')
```

[167-Two Sum II - Input array is sorted](##167-Two Sum II - Input array is sorted) 

[170-Two Sum III - Data structure design](##170-Two Sum III - Data structure design) 

[653-Two Sum IV - Input is a BST](##653-Two Sum IV - Input is a BST) 

[1099-Two Sum Less Than K](##1099-Two Sum Less Than K)

[001-Two Sum](##001-Two Sum)

## 2-Add Two Numbers

加进位符号。

```cpp
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *dummy = new ListNode(-1);
        ListNode *prev = dummy;

        int sum = 0;
        int carry = 0;
        while (l1 || l2) {
            int val1 = l1 ? l1->val : 0; // 
            int val2 = l2 ? l2->val : 0; //

            sum = (carry + val1 + val2) % 10;
            carry = (carry + val1 + val2) / 10;
            prev->next = new ListNode(sum);
            prev = prev->next;   // note

            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }
        if (carry > 0) prev->next = new ListNode(carry);
        return dummy->next;
    }
};
```

[445-Add Two Numbers II](##445-Add Two Numbers II)

## 3-Longest Substring Without Repeating Characters

从头开始用两个指针遍历字符串，用set记录是否有重复，有重复则慢指针向前走，用max函数记录最长个数。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string &s) {
        int ans = 0;
        int i = 0, j = 0;
        set<char> set;
        int length = s.length();
        while (i <= j && j < length) {
            if (set.find(s[j]) == set.end()) {
                set.insert(s[j++]);
                ans = std::max(ans, j - i);
            } else
                set.erase(s[i++]);
        }
        return ans;
    }
};
```

[340-Longest Substring with At Most K Distinct Characters](##340-Longest Substring with At Most K Distinct Characters)

## 4-Median of Two Sorted Arrays

根据总的数组的长度，根据A数组的中位数和B数组的中位数递归的依次缩小范围。

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {
        int sum = nums1.size() + nums2.size();
        double ret;
        if (sum & 1) {
            ret = findKth(nums1, nums2, 0, 0, sum / 2 + 1);
        } else {
            ret = ((findKth(nums1, nums2, 0, 0, sum / 2)) +
                   findKth(nums1, nums2, 0, 0, sum / 2 + 1)) / 2.0;
        }
        return ret;
    }

    double findKth(vector<int> &A, vector<int> &B, int A_st, int B_st, int k) {
        if (A_st >= A.size()) {
            return B[B_st + k - 1];
        }
        if (B_st >= B.size()) {
            return A[A_st + k - 1];
        }
        if (k == 1) return min(A[A_st], B[B_st]);
        int A_mid = k / 2 - 1 >= A.size() ? INT_MAX : A[A_st + k / 2 - 1];
        int B_mid = k / 2 - 1 >= B.size() ? INT_MAX : B[B_st + k / 2 - 1];
        if (A_mid < B_mid) {
            return findKth(A, B, A_st + k / 2, B_st, k - k / 2);
        } else {
            return findKth(A, B, A_st, B_st + k / 2, k - k / 2);
        }
    }
};
```

## 5-Longest Palindromic Substring

先记录1个字符，2个字符的回文长度，然后记录间隔3个以上的字符回文情况。根据开始索引和最长长度取子串。

```cpp
约束条件为：
table[i + 1][j - 1] && s[i] == s[j]
class Solution {
public:
    string longestPalindrome(string &s) {
        int length = s.size();
        if (length == 0)
            return "";

        bool table[length][length];
        memset(table, 0, sizeof(table));

        int start = 0;
        int maxLength = 1;

        for (int i = 0; i < length; i++) {
            table[i][i] = true;
        }
        for (int i = 0; i < length - 1; i++) {
            if (s[i] == s[i + 1]) {
                table[i][i + 1] = true;
                start = i;
                maxLength = 2;
            }
        }
        for (int k = 3; k <= length; k++) {
            for (int i = 0; i < length - k + 1; i++) {
                int j = i + k - 1;
                if (table[i + 1][j - 1] && s[i] == s[j]) {
                    table[i][j] = true;
                    if (k > maxLength) {
                        start = i;
                        maxLength = k;
                    }
                }
            }
        }
        return s.substr(start, maxLength);
    }
};
```

[516-Longest Palindromic Subsequence](##516-Longest Palindromic Subsequence)

## 7-Reverse Integer

商和余数切换。

```cpp
class Solution {
    /*
     * -24 / 10 = -2
     */
public:
    int reverse(int x) {
        int ret = 0;
        while (x != 0) {
            int remainder = x % 10;
            x /= 10;
            if (ret > INT32_MAX / 10 || (ret == INT32_MAX / 10 && remainder > 7)) return 0;
            if (ret < INT32_MIN / 10 || (ret == INT32_MIN / 10 && remainder < -8)) return 0;
            ret = ret * 10 + remainder;
        }
        return ret;
    }
};
```

[190-Reverse Bits](##190-Reverse Bits)

[191-Number of 1 Bits](##191-Number of 1 Bits)

## 8-String to Integer (atoi)

去空格，判断符号，累加及异常处理。

```cpp
class Solution {
public:
    int myAtoi(string &str) {
        int i = 0, length = str.length(), sigh = 1;
        long long ret = 0;

        while (i < length && str[i] == ' ') i++;
        if (i == length) return 0;

        if (str[i] == '+') {
            sigh = 1;
            i++;
        } else if (str[i] == '-') {
            sigh = -1;
            i++;
        }

        for (; i < length; i++) {
            if (str[i] < '0' || str[i] > '9') break;
            ret = ret * 10 + (str[i] - '0');
            if (ret > INT_MAX) break;
        }
        ret *= sigh;
        if (ret > INT_MAX) return INT_MAX;
        if (ret < INT_MIN) return INT_MIN;
        return ret;
    }
};
```



## 10-Regular Expression Matching
## 11-Container With Most Water

隔板问题：在数组两头建立索引，从两头开始遍历，每次移动较小的索引，max更新最大值。

```cpp
class Solution {
public:
    int maxArea(vector<int> &height) {
        int start = 0;
        int end = height.size() - 1;
        int res = 0;

        while (start < end) {
            res = max(res, min(height[start], height[end]) * (end - start));
            if (height[start] > height[end])
                end--;
            else
                start++;
        }
        return res;
    }
};
```

[42-Trapping Rain Water](##42-Trapping Rain Water)

## 13-Roman to Integer

规则题目

```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> map;
        map.insert({'I', 1});
        map.insert({'V', 5});
        map.insert({'X', 10});
        map.insert({'L', 50});
        map.insert({'C', 100});
        map.insert({'D', 500});
        map.insert({'M', 1000});

        int ans = 0;
        ans += (*map.find(s[0])).second;

        for (int i = 1; i < s.length(); i++) {
            ans += (*map.find(s[i])).second;
            if ((*map.find(s[i - 1])).second < (*map.find(s[i])).second)
                ans -= (*map.find(s[i - 1])).second * 2;
        }
        return ans;
    }
};
```



## 14-Longest Common Prefix

以第一个字符串为anchor，然后循环遍历其他的。

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string> &strs) {
        if (strs.empty())
            return "";

        string res;
        for (int i = 0; i < strs[0].length(); i++) {
            for (int j = 1; j < strs.size(); j++) {
                if (strs[j].length() < i || strs[0][i] != strs[j][i])
                    return res;
            }
            res.append(1, strs[0][i]);
        }
        return res;
    }
};
```



## 15-3Sum

固定一个数字，另外两个数字求two sum，注意对拍好顺序的数字去重，三个数字都需要去重。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int> &nums) {
        vector<vector<int>> res;
        sort(begin(nums), end(nums));
        for (int i = 0; i < nums.size(); i++) {
            int j = i + 1;
            int k = nums.size() - 1;
            while (j < k) {
                if (nums[i] + nums[j] + nums[k] == 0) {
                    res.push_back(vector<int>{nums[i], nums[j], nums[k]});
                    j++;
                    k--;
                    while (j < k && nums[j - 1] == nums[j]) j++;
                    while (j < k && nums[k + 1] == nums[k]) k--;
                } else if (nums[i] + nums[j] + nums[k] > 0)
                    k--;
                else
                    j++;
                while (i + 1 < nums.size() && nums[i] == nums[i + 1]) i++;
            }
        }
        return res;
    }
};
```

[016-3Sum Closest](##016-3Sum Closest) 

[259-3Sum Smaller](##259-3Sum Smaller)



## 17-Letter Combinations of a Phone Number

回溯法的套路是，（res，初始化值，限制条件）限制条件不唯一。限制条件初始为数字，更新条件为数字的子串。

```cpp
class Solution {
public:
    vector<string> keyboard{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> res;

    vector<string> letterCombinations(string &digits) {
        if (digits.length() == 0)
            return {};
        backtracking("", digits);
        return res;
    }

    void backtracking(string combination, string digits) {
        if (digits.length() == 0)
            res.push_back(combination);
        else {
            string letters = keyboard[digits[0] - '0'];
            for (char letter: letters)
                backtracking(combination + letter, digits.substr(1));
        }
    }
};
```

[22-Generate Parentheses](##22-Generate Parentheses)

## 19-Remove Nth Node From End of List

两个指针间隔n个距离，最后判断n是否小于链表的长度。

```cpp
class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        ListNode *first = dummy;
        ListNode *second = dummy;
        int i = 0;
        while (first->next && i++ < n) {
            first = first->next;
        }
        while (first->next) {
            first = first->next;
            second = second->next;
            i++;
        }
        if (n > i)
            return nullptr;
        else {
            second->next = second->next->next;
            return dummy->next;
        }

    }
};
```

[234-Palindrome Linked List](##234-Palindrome Linked List)

[206-Reverse Linked List](##206-Reverse Linked List)

[092-Reverse Linked List II](##092-Reverse Linked List II)

## 20-Valid Parentheses

使用栈维护左括号，右括号分3种情况各自分析。

```cpp
class Solution {
public:
    bool isValid(string &str) {
        stack<char> s;
        for (int i = 0; i < str.length(); i++) {
            if (str[i] == '(' || str[i] == '[' || str[i] == '{')
                s.push(str[i]);
            if (str[i] == ')') {
                if (s.empty() || s.top() != '(')
                    return false;
                else
                    s.pop();
            }
            if (str[i] == ']') {
                if (s.empty() || s.top() != '[')
                    return false;
                else
                    s.pop();
            }
            if (str[i] == '}') {
                if (s.empty() || s.top() != '{')
                    return false;
                else
                    s.pop();
            }
        }
        return s.empty();
    }
};
```



## 21-Merge Two Sorted Lists

建立伪节点，通过节点值的大小将链表融合，判断到达一个链表的结尾的处理。

```cpp
class Solution {
public:
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        ListNode *dummy = new ListNode(0);
        ListNode *head = dummy;

        if (l1 == nullptr && l2 == nullptr)
            return nullptr;

        while (l1 != nullptr || l2 != nullptr) {
            if (l1 == nullptr) {
                head->next = l2;
                break;
            }
            if (l2 == nullptr) {
                head->next = l1;
                break;
            }

            if (l1->val > l2->val) {
                head->next = l2;
                l2 = l2->next;
                head = head->next;
            } else {
                head->next = l1;
                l1 = l1->next;
                head = head->next;
            }
        }
        return dummy->next;
    }
};
```

[006-Merge Sorted Array](##006-Merge Sorted Array)

[88-Merge Sorted Array](##88-Merge Sorted Array)

[23-Merge k Sorted Lists](##23-Merge k Sorted Lists)

[486-Merge k Sorted Arrays](##486-Merge k Sorted Arrays)

## 22-Generate Parentheses

回溯法的套路是，（res，初始化值，限制条件）限制条件不唯一。限制条件初始为左括号，右括号和最大的括号数，更新条件为左括号小于最大括号数，右括号小于左括号数。

```cpp
class Solution {
public:
    vector<string> res;

    vector<string> generateParenthesis(int n) {
        backtracking("", 0, 0, n);
        return res;
    }

    void backtracking(string curr, int open, int close, int max) {
        if (curr.length() == 2 * max)
            res.push_back(curr);

        if (open < max)
            backtracking(curr + "(", open + 1, close, max);
        if (close < open)
            backtracking(curr + ")", open, close + 1, max);
    }
};
```



## 23-Merge k Sorted Lists

根据分治策略划分左右两边list，退出条件是是剩下单个list，最后merge的时候返回合并后的list，

```cpp
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        if (lists.empty())
            return nullptr;
        return mergeHelper(lists, 0, lists.size() - 1);
    }

    ListNode *mergeHelper(vector<ListNode *> &lists, int start, int end) {
        if (start >= end)
            return lists[start];

        int mid = (end - start) / 2 + start;
        ListNode *left = mergeHelper(lists, start, mid);
        ListNode *right = mergeHelper(lists, mid + 1, end);
        return mergeTwoLists(left, right);
    }

    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        ListNode *dummy = new ListNode(0);
        ListNode *head = dummy;

        if (l1 == nullptr && l2 == nullptr)
            return nullptr;

        while (l1 != nullptr || l2 != nullptr) {
            if (l1 == nullptr) {
                head->next = l2;
                break;
            }
            if (l2 == nullptr) {
                head->next = l1;
                break;
            }

            if (l1->val > l2->val) {
                head->next = l2;
                l2 = l2->next;
                head = head->next;
            } else {
                head->next = l1;
                l1 = l1->next;
                head = head->next;
            }
        }
        return dummy->next;
    }
};
```



## 26-Remove Duplicates from Sorted Array

使用两个指针，慢指针维护值不相等元素的位置，相邻不相等则移动。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int> &nums) {
        if (nums.empty())
            return 0;
        int i = 0;
        for (int j = 1; j < nums.size(); j++) {
            if (nums[j - 1] != nums[j]) {
                i++;
                nums[i] = nums[j];
            }
        }
        return i + 1;
    }
};
```

[027-Remove Element](##027-Remove Element)

[080-Remove Duplicates from Sorted Array II](##080-Remove Duplicates from Sorted Array II)

## 28-Implement strStr()

两个无条件指针，循环里边3个判断条件，一个符合，一个超界，一个下移。

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.length() == 0)
            return 0;

        for (int i = 0;; i++) {
            for (int j = 0;; j++) {
                if (needle.length() == j)
                    return i;
                if (haystack.length() < i + j)
                    return -1;
                if (needle[j] != haystack[i + j])
                    break;
            }
        }
    }
};
```



## 29-Divide Two Integers

以2^n的速度逼近目标值。

```cpp
class Solution {
public:
    int divide(int dividend, int divisor) {
        if (divisor == 0)
            return INT_MAX;
        if (dividend == 0)
            return 0;
        int sign = 1;
        if ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))
            sign = -1;
        long dividend_temp = abs(long(dividend));
        long divisor_temp = abs(long(divisor));
        long ans = divideUtil(dividend_temp, divisor_temp);

        if (INT_MAX < ans * sign)
            return INT_MAX;
        if (INT_MIN > ans * sign)
            return INT_MIN;

        return ans * sign;
    }

private:
    long divideUtil(long dividend, long divisor) {
        if (dividend < divisor)
            return 0;
        long sum = divisor;
        long multiple = 1;
        while (sum * 2 <= dividend) {
            sum *= 2;
            multiple *= 2;
        }
        return multiple + divideUtil(dividend - sum, divisor);
    }
};
```

[50-Pow(x, n)](##50-Pow(x, n))

[69-Sqrt(x)](##69-Sqrt(x))

## 33-Search in Rotated Sorted Array

二分查找，分别在条件下，加入分支。

```cpp
class Solution {
public:
    int search(vector<int> &nums, int target) {
        if (nums.empty())
            return -1;

        int start = 0;
        int end = nums.size() - 1;
        while (start <= end) {
            int mid = (start + end) / 2;
            if (nums[mid] == target)
                return mid;
            if (nums[start] <= nums[mid]) {
                if (nums[start] <= target && target < nums[mid]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            }
            if (nums[mid] <= nums[end]) {
                if (nums[mid] < target && target <= nums[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

[153-Find Minimum in Rotated Sorted Array](##153-Find Minimum in Rotated Sorted Array)

[154-Find Minimum in Rotated Sorted Array II](##154-Find Minimum in Rotated Sorted Array II)

## 34-Find First and Last Position of Element in Sorted Array
## 36-Valid Sudoku
## 38-Count and Say
## 41-First Missing Positive
## 42-Trapping Rain Water

台阶问题：需要不断更新左台阶和右台阶的高度，根据高度差max函数更新最大值。

```cpp
class Solution {
public:
    int trap(vector<int> &height) {
        int left = 0, right = height.size() - 1, ans = 0;
        int left_max = 0, right_max = 0;

        while (left < right) {
            if (height[left] < height[right]) {
                height[left] >= left_max ? left_max = height[left] : ans += left_max - height[left];
                left++;
            } else {
                height[right] >= right_max ? right_max = height[right] : ans += right_max - height[right];
                right--;
            }
        }
        return ans;
    }
};
```



## 44-Wildcard Matching
## 46-Permutations

回溯法的套路，当出现重复时，加入visit标记记录。

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int> &nums) {
        vector<vector<int>> res;
        vector<int> templist;
        vector<int> visit(nums.size(), 0);
        sort(nums.begin(), nums.end());
        backtracking(res, templist, nums, visit);
        return res;
    }

private:
//    visit[i - 1]  and !visit[i - 1] all works
    void backtracking(vector<vector<int>> &res, vector<int> templist, vector<int> &nums, vector<int> &visit) {
        if (nums.size() == templist.size())
            res.push_back(templist);
        else {
            for (int i = 0; i < nums.size(); i++) {
                if (visit[i] || (i > 0 && nums[i - 1] == nums[i] && visit[i - 1]))
                    continue;
                visit[i] = 1;
                templist.push_back(nums[i]);
                backtracking(res, templist, nums, visit);
                visit[i] = 0;
                templist.pop_back();
            }
        }
    }
};
```

[047-Permutations II](##047-Permutations II)

[039-Combination Sum](##039-Combination Sum)

[131-Palindrome Partitioning](##131-Palindrome Partitioning)

[78-Subsets](##78-Subsets)

## 48-Rotate Image
## 49-Group Anagrams
## 50-Pow(x, n)

以2^n的速度逼近目标值。

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        bool isNegative = false;
        if (n < 0) {
            isNegative = true;
            n = -(n + 1);
            x = 1 / x;
        }
        double ans = powUtil(x, n);
        if (isNegative)
            return ans * x;
        return ans;
    }

private:
    double powUtil(double x, int n) {
        if (n == 0)
            return 1;
        return n % 2 == 0 ? powUtil(x * x, n / 2) : x * powUtil(x * x, n / 2);
    }
};
```



## 53-Maximum Subarray

分治策略

```cpp
class Solution {
public:
    int maxSubArray(vector<int> &nums) {
        if (nums.empty())
            return 0;
        return helper(nums, 0, nums.size() - 1);

    }

    int helper(vector<int> &nums, int start, int end) {
        if (start == end)
            return nums[start];

        int mid = (end + start) / 2;

        int left = helper(nums, start, mid);
        int right = helper(nums, mid + 1, end);
        int crossingSum = maxCrossingSum(nums, start, end, mid);
        
        return max(left, right, crossingSum);
    }

    int maxCrossingSum(vector<int> &nums, int start, int end, int mid) {
        int sum = 0;
        int left_sum = INT_MIN;
        for (int i = mid; i >= start; i--) {
            sum = sum + nums[i];
            if (sum > left_sum)
                left_sum = sum;
        }
        sum = 0;
        int right_sum = INT_MIN;
        for (int i = mid + 1; i <= end; i++) {
            sum = sum + nums[i];
            if (sum > right_sum)
                right_sum = sum;
        }
        return left_sum + right_sum;
    }
    
    int max(int a, int b, int c) {
        return (a > b ? a : b) > c ? (a > b ? a : b) : c;
    }
};
```



## 54-Spiral Matrix
## 55-Jump Game
## 56-Merge Intervals
## 62-Unique Paths
## 66-Plus One
## 69-Sqrt(x)

二分查找缩小范围，logn

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int start = 0, end = x;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            int div = x / mid;
            if (div == mid)
                return mid;
            else if (div > mid) {
                start = mid;
            } else
                end = mid;
        }
        if (x != 0 && x / end >= end)
            return end;
        return start;
    }
};
```



## 70-Climbing Stairs
## 73-Set Matrix Zeroes
## 75-Sort Colors
## 76-Minimum Window Substring
## 78-Subsets

控制元素的起始位置。

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int> &nums) {
        vector<vector<int>> res;
        vector<int> subset;
        backtracking(res, subset, nums, 0);
        return res;
    }

private:
    void backtracking(vector<vector<int>> &res, vector<int> &subset, vector<int> &nums, int start) {
        res.push_back(subset);
        for (int i = start; i < nums.size(); i++) {
            subset.push_back(nums[i]);
            backtracking(res, subset, nums, i + 1);
            subset.pop_back();
        }
    }
};
```

[090-Subsets II](##090-Subsets II)

## 79-Word Search
## 84-Largest Rectangle in Histogram
## 88-Merge Sorted Array

通过值的大小融合，判断到达一个数组结尾的处理。

```cpp
class Solution {
public:
    void merge(vector<int> &nums1, int m, vector<int> &nums2, int n) {
        int i = m - 1, j = n - 1, len = nums1.size() - 1;
        while (-1 < i || -1 < j) {
            if (-1 == i) {
                nums1[len] = nums2[j];
                j--;
                len--;
                continue;
            }
            if (-1 == j) {
                nums1[len] = nums1[i];
                i--;
                len--;
                continue;
            }
            if (nums1[i] < nums2[j]) {
                nums1[len] = nums2[j];
                j--;
                len--;
            } else {
                nums1[len] = nums1[i];
                i--;
                len--;
            }
        }
    }
};
```



## 91-Decode Ways
## 94-Binary Tree Inorder Traversal

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> res;
        inorderTraversalUtils(root, res);
        return res;
    }

private:
    void inorderTraversalUtils(TreeNode *root, vector<int> &res) {
        if (root == nullptr)
            return;
        inorderTraversalUtils(root->left, res);
        res.push_back(root->val);
        inorderTraversalUtils(root->right, res);
    }
};
```

[144-Binary Tree Preorder Traversal](##144-Binary Tree Preorder Traversal)

[145-Binary Tree Postorder Traversal](##145-Binary Tree Postorder Traversal)

## 98-Validate Binary Search Tree
## 101-Symmetric Tree
## 102-Binary Tree Level Order Traversal

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        vector<vector<int>> res;
        if (!root)
            return res;

        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            int level_length = q.size();
            vector<int> level;
            for (int i = 0; i < level_length; i++) {
                TreeNode *curr = q.front();
                level.push_back(curr->val);
                q.pop();
                if (curr->left)
                    q.push(curr->left);
                if (curr->right)
                    q.push(curr->right);
            }
            res.push_back(level);
        }
        return res;
    }
};
```

[107-Binary Tree Level Order Traversal II](##107-Binary Tree Level Order Traversal II)

## 103-Binary Tree Zigzag Level Order Traversal

建立标志位，每一个level更新一下。然后根据标志位的不用，在添加之前reverse vector。

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
        vector<vector<int>> res;
        if (!root)
            return res;

        queue<TreeNode *> q;
        q.push(root);
        bool flag = true;
        while (!q.empty()) {
            int level_length = q.size();
            vector<int> level;
            flag = !flag;
            for (int i = 0; i < level_length; i++) {
                TreeNode *curr = q.front();
                level.push_back(curr->val);
                q.pop();
                if (curr->left)
                    q.push(curr->left);
                if (curr->right)
                    q.push(curr->right);
            }
            if (flag)
                reverse(level.begin(), level.end());
            res.push_back(level);
        }
        return res;
    }
};
```

[314-Binary Tree Vertical Order Traversal](##314-Binary Tree Vertical Order Traversal)

[993-Cousins in Binary Tree](##993-Cousins in Binary Tree)

## 104-Maximum Depth of Binary Tree

递归求解，退出条件，空节点为0，叶子节点为1，然后返回左右节点最大值，再加1.

```cpp
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == nullptr)
            return 0;
        if (root->left == nullptr && root->right == nullptr)
            return 1;

        int left = INT_MAX, right = INT_MAX;
        if (root->left)
            left = minDepth(root->left);
        if (root->right)
            right = minDepth(root->right);

        return max(left, right) + 1;
    }
};
```



[111-Minimum Depth of Binary Tree](##111-Minimum Depth of Binary Tree)

[993-Cousins in Binary Tree](##993-Cousins in Binary Tree)

## 105-Construct Binary Tree from Preorder and Inorder Traversal

在先序中找root值（rootVal）首个，在中序中找root位置（rootPos）

递归退出条件：单个节点退出

遍历完成之后没有找到，异常退出

```cpp
class Solution {
public:
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
        if (preorder.empty() || preorder.size() != inorder.size())
            return nullptr;

        int length = preorder.size();
        return constructHelper(preorder, 0, length - 1, inorder, 0, length - 1);

    }

private:
    TreeNode *constructHelper(vector<int> &pre, int startPre, int endPre, vector<int> &vin, int startVin, int endVin) {
        int rootValue = pre[startPre];
        TreeNode *root = new TreeNode(rootValue);

        if (pre[startPre] == pre[endPre]) {
            if (vin[startVin] == vin[endVin] && pre[startPre] == vin[startVin])
                return root;
            else
                throw invalid_argument("invalid_argument");
        }

        int rootPos = startVin;
        while (startVin <= endVin && rootValue != vin[rootPos])
            rootPos++;
        if (rootPos == endVin && rootValue != vin[rootPos])
            throw invalid_argument("invalid_argument");

        int leftLength = rootPos - startVin;
        int leftPreEnd = startPre + leftLength;

        if (0 < leftLength)
            root->left = constructHelper(pre, startPre + 1, leftPreEnd, vin, startVin, rootPos - 1);
        if (leftLength < endPre - startPre)
            root->right = constructHelper(pre, leftPreEnd + 1, endPre, vin, rootPos + 1, endVin);

        return root;
    }
};
```

[255-Verify Preorder Sequence in Binary Search Tree](##255-Verify Preorder Sequence in Binary Search Tree)

## 108-Convert Sorted Array to Binary Search Tree
## 116-Populating Next Right Pointers in Each Node
## 118-Pascal's Triangle
## 121-Best Time to Buy and Sell Stock

记录min_val，向后更新max_profit。

```cpp
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int max_profit = 0, min_val = INT_MAX;
        for (int &price:prices) {
            if (price < min_val)
                min_val = price;
            if ((price - min_val) > max_profit)
                max_profit = price - min_val;
        }
        return max_profit;
    }
};
```

[122-Best Time to Buy and Sell Stock II](##122-Best Time to Buy and Sell Stock II)

[123-Best Time to Buy and Sell Stock III](##123-Best Time to Buy and Sell Stock III)

[188-Best Time to Buy and Sell Stock IV](##188-Best Time to Buy and Sell Stock IV)



## 122-Best Time to Buy and Sell Stock II

后一个值大于前一个值，则累加。

```cpp
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int max_profit = 0;
        for (int i = 1; i < prices.size(); i++) {
            if (prices[i] > prices[i - 1])
                max_profit += prices[i] - prices[i - 1];
        }
        return max_profit;
    }
};
```



## 124-Binary Tree Maximum Path Sum
## 125-Valid Palindrome
## 127-Word Ladder
## 128-Longest Consecutive Sequence
## 130-Surrounded Regions
## 131-Palindrome Partitioning

```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        vector<string> templist;
        backtracking(res, templist, s, 0);
        return res;
    }

private:
    void backtracking(vector<vector<string>> &res, vector<string> &templist, string &s, int start) {
        if (start == s.length())
            res.push_back(templist);
        else {
            for (int i = start; i < s.length(); i++) {
                if (isPalindrome(s.substr(start, i - start + 1))) {
                    templist.push_back(s.substr(start, i - start + 1));
                    backtracking(res, templist, s, i + 1);
                    templist.pop_back();
                }
            }
        }
    }

    bool isPalindrome(string s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s[left] != s[right])
                return false;
            left++;
            right--;
        }
        return true;
    }
};
```



## 134-Gas Station
## 136-Single Number
## 138-Copy List with Random Pointer
## 139-Word Break
## 140-Word Break II
## 141-Linked List Cycle
## 146-LRU Cache
## 148-Sort List
## 149-Max Points on a Line
## 150-Evaluate Reverse Polish Notation
## 152-Maximum Product Subarray
## 155-Min Stack

用两个栈维护。

```cpp
class MinStack {
//    push     minstk.top() >= x
public:
    /** initialize your data structure here. */
    stack<int> stk, minstk;

    MinStack() {
    }

    void push(int x) {
        stk.push(x);
        if (minstk.empty() or minstk.top() >= x)
            minstk.push(x);
    }

    void pop() {
        int top = stk.top();
        if (top == minstk.top())
            minstk.pop();
        stk.pop();
    }

    int top() {
        return stk.top();
    }

    int getMin() {
        return minstk.top();
    }
};
```



## 160-Intersection of Two Linked Lists
## 162-Find Peak Element
## 163-Missing Ranges
## 166-Fraction to Recurring Decimal
## 169-Majority Element
## 171-Excel Sheet Column Number
## 172-Factorial Trailing Zeroes
## 179-Largest Number
## 189-Rotate Array
## 190-Reverse Bits

n必须是从左边向右边移动，每次取最低位的值。

```cpp
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for (int i = 0; i < 32; i++) {
            res = (res << 1) + (n >> i & 1);
        }
        return res;
    }
};
```

## 191-Number of 1 Bits

n必须是从左边向右边移动，每次取最低位的值，如果值为1，则记录。

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            if ((n >> i & 1) == 1)
                res++;
        }
        return res;
    }
};
```



## 198-House Robber
## 200-Number of Islands
## 202-Happy Number
## 204-Count Primes
## 206-Reverse Linked List

循环遍历的时候需要记录前一个节点和后一个节点。

递归遍历的退出条件为到达最后一个节点。

```cpp
ListNode *reverseLinklistRecursiveUtils(ListNode *curr, ListNode *prev) {
    if (!curr->next) {
        curr->next = prev;
        return curr;
    }
    ListNode *next = curr->next;
    curr->next = prev;
    return reverseLinklistRecursiveUtils(next, curr);
}

ListNode *reverseLinklistRecursive(ListNode *head) {
    if (!head)
        return nullptr;
    return reverseLinklistRecursiveUtils(head, nullptr);
}

ListNode *reverseLinklistIterative(ListNode *head) {

    ListNode *curr = head;
    ListNode *prev = nullptr, *next = nullptr;
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
```



## 207-Course Schedule
## 208-Implement Trie (Prefix Tree)
## 210-Course Schedule II
## 212-Word Search II
## 215-Kth Largest Element in an Array
## 217-Contains Duplicate
## 218-The Skyline Problem
## 227-Basic Calculator II
## 230-Kth Smallest Element in a BST
## 234-Palindrome Linked List

建立两个指针遍历链表，fast的速度是slow的两倍，借助栈存放slow指针的数字，根据奇偶个数调整slow指针的位置，然后将栈中的数值与slow指针的值比较，如果都一致，则true

```cpp
class Solution {
public:
    bool isPalindrome(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        stack<int> s;

        while (fast != nullptr && fast->next != nullptr) {
            s.push(slow->val);
            fast = fast->next->next;
            slow = slow->next;
        }

        if (fast != nullptr)
            slow = slow->next;

        while (slow != nullptr) {
            if (slow->val != s.top())
                return false;
            slow = slow->next;
            s.pop();
        }
        return true;
    }
};
```



## 236-Lowest Common Ancestor of a Binary Tree
## 237-Delete Node in a Linked List
## 238-Product of Array Except Self
## 239-Sliding Window Maximum
## 240-Search a 2D Matrix II
## 242-Valid Anagram
## 251-Flatten 2D Vector
## 253-Meeting Rooms II
## 268-Missing Number
## 269-Alien Dictionary
## 277-Find the Celebrity
## 279-Perfect Squares
## 283-Move Zeroes
## 285-Inorder Successor in BST
## 287-Find the Duplicate Number
## 289-Game of Life
## 295-Find Median from Data Stream
## 297-Serialize and Deserialize Binary Tree
## 300-Longest Increasing Subsequence

动态规划解答，每次都将索引值前边的元素遍历一遍，比较索引值与前边值的大小，并更新递增数。

```
最优结构为：
dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;
```

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int> &nums) {
        if (nums.empty())
            return 0;
        vector<int> dp(nums.size(), 0);
        int max_value = 0;
        for (int i = 0; i < nums.size(); i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i])
                    dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;
            }
            if (dp[i] > max_value)
                max_value = dp[i];
        }
        return max_value;
    }
};
```



## 308-Range Sum Query 2D - Mutable

## 315-Count of Smaller Numbers After Self
## 322-Coin Change
## 324-Wiggle Sort II
## 326-Power of Three
## 328-Odd Even Linked List
## 329-Longest Increasing Path in a Matrix
## 334-Increasing Triplet Subsequence

用vector记录两个最小值，用条件判断更新值是否大于记录的两个值，如果大于则为true。

```cpp
class Solution {
//    vector<int> records(2, INT_MAX)  !=  vector<int> records{2, INT_MAX};
public:
    bool increasingTriplet(vector<int> &nums) {
        if (nums.size() < 3)
            return false;
        vector<int> records(2, INT_MAX);
        for (int &num:nums) {
            if (num <= records[0]) {
                records[0] = num;
            } else if (num <= records[1]) {
                records[1] = num;
            } else {
                return true;
            }
        }
        return false;
    }
};
```



## 340-Longest Substring with At Most K Distinct Characters

使用数组记录每个字符出现的次数并记录，使用set记录不合适，因为需要记录对应字符的次数。

```cpp
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string &s, int k) {
        // write your code here
        int char_set[256] = {0};  //
        int start = 0, cnt = 0, ans = 0;

        for (int i = 0; i < s.size(); i++) {
            if (char_set[s[i]]++ == 0) cnt++;
            while (cnt > k) {
                char_set[s[start]]--;
                if (char_set[s[start++]] == 0)cnt--; //
            }
            ans = max(i - start + 1, ans);
        }
        return ans;
    }
};
```



## 341-Flatten Nested List Iterator
## 344-Reverse String
## 347-Top K Frequent Elements
## 348-Design Tic-Tac-Toe
## 350-Intersection of Two Arrays II
## 371-Sum of Two Integers
## 378-Kth Smallest Element in a Sorted Matrix
## 380-Insert Delete GetRandom O(1)
## 384-Shuffle an Array
## 387-First Unique Character in a String
## 395-Longest Substring with At Least K Repeating Characters
## 412-Fizz Buzz
## 454-4Sum II

# Lintcode

## 006-Merge Sorted Array

建立新vector，通过节点值的大小将数组融合，判断到达一个数组的结尾的处理，数组需要循环遍历。

```cpp
class Solution {
//    100% test cases passedTotal runtime 15 ms
//            Your submission beats 52.80% Submissions
public:
    /**
     * @param A: sorted integer array A
     * @param B: sorted integer array B
     * @return: A new sorted integer array
     */
    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {
        // write your code here
        if (A.empty() || B.empty()) {
            if (A.empty())
                return B;
            else if (B.empty())
                return A;
            else return {};
        }

        vector<int> res;
        int i = 0, j = 0;
        while (i < A.size() || j < B.size()) {
            if (A.size() == i) {
                res.push_back(B[j]);
                j++;
                continue;
            }
            if (B.size() == j) {
                res.push_back(A[i]);
                i++;
                continue;
            }
            if (A[i] < B[j]) {
                res.push_back(A[i]);
                i++;
            } else {
                res.push_back(B[j]);
                j++;
            }
        }
        return res;
    }
};
```

## 486-Merge k Sorted Arrays

根据分治策略划分左右两边list，退出条件是是剩下单个list，最后merge的时候返回合并后的list，

```cpp
class Solution {
//    100% test cases passedTotal runtime 1107 ms
//            Your submission beats 88.60% Submissions!
public:
    /**
     * @param arrays: k sorted integer arrays
     * @return: a sorted array
     */
    vector<int> mergekSortedArrays(vector<vector<int>> &arrays) {
        // write your code here
        if (arrays.empty())
            return {};
        return mergeHelper(arrays, 0, arrays.size() - 1);
    }

    vector<int> mergeHelper(vector<vector<int>> &arrays, int start, int end) {
        if (start >= end)
            return arrays[start];
        int mid = (end + start) / 2;

        vector<int> left = mergeHelper(arrays, start, mid);
        vector<int> right = mergeHelper(arrays, mid + 1, end);
        return mergeSortedArray(left, right);
    }

    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {
        // write your code here
        if (A.empty() || B.empty()) {
            if (A.empty())
                return B;
            else if (B.empty())
                return A;
            else return {};
        }

        vector<int> res;
        int i = 0, j = 0;
        while (i < A.size() || j < B.size()) {
            if (A.size() == i) {
                res.push_back(B[j]);
                j++;
                continue;
            }
            if (B.size() == j) {
                res.push_back(A[i]);
                i++;
                continue;
            }
            if (A[i] < B[j]) {
                res.push_back(A[i]);
                i++;
            } else {
                res.push_back(B[j]);
                j++;
            }
        }
        return res;
    }
};
```



# others

## 001-Two Sum
## 002-Add Two Numbers
## 003-Longest Substring Without Repeating Characters
## 004-Median of Two Sorted Arrays
## 005-Longest Palindromic Substring
## 006-ZigZag Conversion
## 007-Reverse Integer
## 008-String to Integer (atoi)
## 009-Palindrome Number
## 010-Regular Expression Matching
## 011-Container With Most Water
## 012-Integer to Roman
## 013-Roman to Integer
## 014-Longest Common Prefix
## 015-3Sum
## 016-3Sum Closest

用绝对值更新3sum和target的差值，留最小的。

```cpp
class Solution {
public:
    int threeSumClosest(vector<int> &nums, int target) {
        int res = -1;
        sort(nums.begin(), nums.end());
        int min_diff = INT_MAX;
        for (int i = 0; i < nums.size(); i++) {
            int j = i + 1;
            int k = nums.size() - 1;
            while (j < k) {
                int sum3 = nums[i] + nums[j] + nums[k];
                if (abs(sum3 - target) < min_diff) {
                    min_diff = abs(sum3 - target);
                    res = sum3;
                    if (min_diff == 0)
                        return sum3;
                }
                if (sum3 > target)
                    k--;
                else
                    j++;
            }
        }
        return res;
    }
};
```



## 017-Letter Combinations of a Phone Number
## 018-4Sum
## 019-Remove Nth Node From End of List
## 020-Valid Parentheses
## 021-Merge Two Sorted Lists
## 022-Generate Parentheses
## 023-Merge k Sorted Lists
## 024-Swap Nodes in Pairs
## 025-Reverse Nodes in k-Group
## 026-Remove Duplicates from Sorted Array
## 027-Remove Element

使用两个指针，慢指针维护值不相等元素的位置，元素不等于目标值则移动。

```cpp
class Solution {
//    from 0;  return i not i+1
public:
    int removeElement(vector<int> &nums, int val) {
        if (nums.empty())
            return 0;
        int i = 0;
        for (int j = 0; j < nums.size(); j++) {
            if (val != nums[j]) {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
};
```



## 028-Implement strStr()
## 029-Divide Two Integers
## 030-Substring with Concatenation of All Words
## 031-Next Permutation
## 032-Longest Valid Parentheses
## 033-Search in Rotated Sorted Array
## 034-Find First and Last Position of Element in Sorted Array
## 035-Search Insert Position
## 036-Valid Sudoku
## 037-Sudoku Solver
## 038-Count and Say
## 039-Combination Sum

不断的缩小target的值，不断回溯。

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int> &nums, int target) {
        vector<vector<int>> res;
        vector<int> templist;
        sort(nums.begin(), nums.end());
        backtracking(res, templist, nums, target, 0);
        return res;
    }

private:
    void backtracking(vector<vector<int>> &res, vector<int> &templist, vector<int> &nums, int target, int start) {
        if (target < 0)
            return;
        else if (target == 0)
            res.push_back(templist);
        else {
            for (int i = start; i < nums.size(); i++) {
                templist.push_back(nums[i]);
                backtracking(res, templist, nums, target - nums[i], i);
                templist.pop_back();
            }
        }
    }
};
```

[040-Combination Sum II](##040-Combination Sum II)

## 040-Combination Sum II

相邻元素相等则跳过。

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int> &nums, int target) {
        vector<vector<int>> res;
        vector<int> templist;
        vector<int> visit(nums.size(), 0);
        sort(nums.begin(), nums.end());
        backtracking(res, templist, visit, nums, target, 0);
        return res;
    }

private:
    void
    backtracking(vector<vector<int>> &res, vector<int> &templist, vector<int> &visit, vector<int> &nums, int target,
                 int start) {
        if (target < 0)
            return;
        else if (target == 0)
            res.push_back(templist);
        else {
            for (int i = start; i < nums.size(); i++) {
                if (i > start && nums[i - 1] == nums[i]) {
                    continue;
                }
                visit[i] = 1;
                templist.push_back(nums[i]);
                backtracking(res, templist, visit, nums, target - nums[i], i + 1);
                visit[i] = 0;
                templist.pop_back();
            }
        }
    }
};
```



## 041-First Missing Positive
## 042-Trapping Rain Water
## 043-Multiply Strings
## 044-Wildcard Matching
## 045-Jump Game II
## 046-Permutations

## 047-Permutations II

回溯法的套路，当出现重复时，加入visit标记记录。

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int> &nums) {
        vector<vector<int>> res;
        vector<int> templist;
        vector<int> visit(nums.size(), 0);
        sort(nums.begin(), nums.end());
        backtracking(res, templist, nums, visit);
        return res;
    }

private:
//    visit[i - 1]  and !visit[i - 1] all works
    void backtracking(vector<vector<int>> &res, vector<int> templist, vector<int> &nums, vector<int> &visit) {
        if (nums.size() == templist.size())
            res.push_back(templist);
        else {
            for (int i = 0; i < nums.size(); i++) {
                if (visit[i] || (i > 0 && nums[i - 1] == nums[i] && visit[i - 1]))
                    continue;
                visit[i] = 1;
                templist.push_back(nums[i]);
                backtracking(res, templist, nums, visit);
                visit[i] = 0;
                templist.pop_back();
            }
        }
    }
};
```



## 048-Rotate Image
## 049-Group Anagrams
## 050-Pow(x, n)
## 051-N-Queens
## 052-N-Queens II
## 053-Maximum Subarray
## 054-Spiral Matrix
## 055-Jump Game
## 056-Merge Intervals
## 057-Insert Interval
## 058-Length of Last Word
## 059-Spiral Matrix II
## 060-Permutation Sequence
## 061-Rotate List
## 062-Unique Paths
## 063-Unique Paths II
## 064-Minimum Path Sum
## 065-Valid Number
## 066-Plus One
## 067-Add Binary
## 068-Text Justification
## 069-Sqrt(x)
## 070-Climbing Stairs
## 071-Simplify Path
## 072-Edit Distance
## 073-Set Matrix Zeroes
## 074-Search a 2D Matrix
## 075-Sort Colors
## 076-Minimum Window Substring
## 077-Combinations
## 078-Subsets
## 079-Word Search
## 080-Remove Duplicates from Sorted Array II

使用两个指针，慢指针维护值不相等元素的位置，相邻不相等则移动。else分支加入个数的记录。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int> &nums) {
        if (nums.empty())
            return 0;
        int i = 0;
        int count = 0;
        for (int j = 1; j < nums.size(); j++) {
            if (nums[j - 1] != nums[j]) {
                count = 0;
                i++;
                nums[i] = nums[j];
            } else {
                count++;
                if (count <= 1) {
                    i++;
                    nums[i] = nums[j];
                }
            }
        }
        return i + 1;
    }
};
```



## 081-Search in Rotated Sorted Array II
## 082-Remove Duplicates from Sorted List II
## 083-Remove Duplicates from Sorted List
## 084-Largest Rectangle in Histogram
## 085-Maximal Rectangle
## 086-Partition List
## 087-Scramble String
## 088-Merge Sorted Array
## 089-Gray Code
## 090-Subsets II

相邻一致，则continue

```cpp
class Solution {
//    java debug
public:
    vector<vector<int>> subsetsWithDup(vector<int> &nums) {
        vector<vector<int>> res;
        vector<int> subset;
        sort(nums.begin(), nums.end());
        backtracking(res, subset, nums, 0);
        return res;
    }

private:
    void backtracking(vector<vector<int>> &res, vector<int> &subset, vector<int> &nums, int start) {
        res.push_back(subset);
        for (int i = start; i < nums.size(); i++) {
            if (i > start && nums[i - 1] == nums[i]) {
                continue;
            }
            subset.push_back(nums[i]);
            backtracking(res, subset, nums, i + 1);
            subset.pop_back();
        }
    }
};
```



## 091-Decode Ways
## 092-Reverse Linked List II

根据位置连接。

```cpp
class Solution {
//    1 2 3 4 5
//    mNode->next = postnNode;  
//tail connect the last
public:
    ListNode *reverseBetween(ListNode *head, int m, int n) {
        if (!head || m >= n)
            return head;
        ListNode *dummy = new ListNode(0);
        dummy->next = head;
        head = dummy;

        for (int i = 1; i < m; i++) {
            head = head->next;
        }

        ListNode *premNode = head;
        ListNode *mNode = head->next;
        ListNode *nNode = mNode;
        ListNode *postnNode = mNode->next;
        for (int i = m; i < n; i++) {
            ListNode *temp = postnNode->next;
            postnNode->next = nNode;
            nNode = postnNode;
            postnNode = temp;
        }

        mNode->next = postnNode;
        premNode->next = nNode;
        return dummy->next;
    }
};
```



## 093-Restore IP Addresses
## 094-Binary Tree Inorder Traversal
## 095-Unique Binary Search Trees II
## 096-Unique Binary Search Trees
## 097-Interleaving String
## 098-Validate Binary Search Tree
## 099-Recover Binary Search Tree
## 100-Same Tree
## 101-Symmetric Tree
## 102-Binary Tree Level Order Traversal
## 103-Binary Tree Zigzag Level Order Traversal
## 104-Maximum Depth of Binary Tree
## 105-Construct Binary Tree from Preorder and Inorder Traversal
## 106-Construct Binary Tree from Inorder and Postorder Traversal
## 107-Binary Tree Level Order Traversal II

在vector中insert

```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode *root) {
        vector<vector<int>> res;
        if (!root)
            return res;

        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            int level_length = q.size();
            vector<int> level;
            for (int i = 0; i < level_length; i++) {
                TreeNode *curr = q.front();
                level.push_back(curr->val);
                q.pop();
                if (curr->left)
                    q.push(curr->left);
                if (curr->right)
                    q.push(curr->right);
            }
            res.insert(res.begin(), level);
        }
        return res;
    }
};
```



## 108-Convert Sorted Array to Binary Search Tree
## 109-Convert Sorted List to Binary Search Tree
## 110-Balanced Binary Tree
## 111-Minimum Depth of Binary Tree

递归求解，退出条件，空节点为0，叶子节点为1，然后返回左右节点最小值，再加1.

```cpp
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == nullptr)
            return 0;
        if (root->left == nullptr && root->right == nullptr)
            return 1;

        int left = INT_MAX, right = INT_MAX;
        if (root->left)
            left = minDepth(root->left);
        if (root->right)
            right = minDepth(root->right);

        return min(left, right) + 1;
    }
};
```



## 112-Path Sum
## 113-Path Sum II
## 114-Flatten Binary Tree to Linked List
## 115-Distinct Subsequences
## 116-Populating Next Right Pointers in Each Node
## 117-Populating Next Right Pointers in Each Node II
## 118-Pascal's Triangle
## 119-Pascal's Triangle II
## 120-Triangle
## 121-Best Time to Buy and Sell Stock
## 122-Best Time to Buy and Sell Stock II
## 123-Best Time to Buy and Sell Stock III

```
这道题是Best Time to Buy and Sell Stock的扩展，现在我们最多可以进行两次交易。我们仍然使用动态规划来完成，事实上可以解决非常通用的情况，也就是最多进行k次交易的情况。
这里我们先解释最多可以进行k次交易的算法，然后最多进行两次我们只需要把k取成2即可。我们还是使用“局部最优和全局最优解法”。我们维护两种量，一个是当前到达第i天可以最多进行j次交易，最好的利润是多少（global[i][j]），另一个是当前到达第i天，最多可进行j次交易，并且最后一次交易在当天卖出的最好的利润是多少（local[i][j]）。下面我们来看递推式，全局的比较简单，
global[i][j]=max(local[i][j],global[i-1][j])，
也就是去当前局部最好的，和过往全局最好的中大的那个（因为最后一次交易如果包含当前天一定在局部最好的里面，否则一定在过往全局最优的里面）。对于局部变量的维护，递推式是
local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)，
也就是看两个量，第一个是全局到i-1天进行j-1次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要j-1次交易，最后一次交易取当前天），第二个量则是取local第i-1天j次交易，然后加上今天的差值（这里因为local[i-1][j]比如包含第i-1天卖出的交易，所以现在变成第i天卖出，并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，因为否则就不满足local[i][j]必须在最后一天卖出的条件了）。
上面的算法中对于天数需要一次扫描，而每次要对交易次数进行递推式求解，所以时间复杂度是O(n*k)，如果是最多进行两次交易，那么复杂度还是O(n)。空间上只需要维护当天数据皆可以，所以是O(k)，当k=2，则是O(1)。代码如下： 

版权声明：本文为CSDN博主「Code_Ganker」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/linhuanmars/article/details/23236995

local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)，
local的两种情况分为赚钱的情况和当天交易的情况。 
  
外层循环每次加入交易差额。
```

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int> &prices) {
        if (prices.empty())
            return 0;

        int ans = 0;
        if (k >= prices.size() / 2) {
            for (int i = 1; i < prices.size(); ++i) {
                if (prices[i] - prices[i - 1] > 0) {
                    ans += prices[i] - prices[i - 1];
                }
            }
        } else {
            vector<int> local(k + 1);
            vector<int> global(k + 1);
            for (int i = 0; i < prices.size() - 1; ++i) {
                int increase = prices[i + 1] - prices[i];
                for (int j = k; j >= 1; --j) {
                    local[j] = max(global[j - 1] + max(increase, 0), local[j] + increase);
                    global[j] = max(global[j], local[j]);
                }
            }
            ans = global[k];
        }
        return ans;
    }
};
```





## 124-Binary Tree Maximum Path Sum
## 125-Valid Palindrome
## 126-Word Ladder II
## 127-Word Ladder
## 128-Longest Consecutive Sequence
## 129-Sum Root to Leaf Numbers
## 130-Surrounded Regions
## 131-Palindrome Partitioning
## 132-Palindrome Partitioning II
## 133-Clone Graph
## 134-Gas Station
## 135-Candy
## 136-Single Number
## 137-Single Number II
## 138-Copy List with Random Pointer
## 139-Word Break
## 140-Word Break II
## 141-Linked List Cycle
## 142-Linked List Cycle II
## 143-Reorder List
## 144-Binary Tree Preorder Traversal

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        preorderTraversalUtils(root, res);
        return res;
    }

private:
    void preorderTraversalUtils(TreeNode *root, vector<int> &res) {
        if (root == nullptr)
            return;
        res.push_back(root->val);
        preorderTraversalUtils(root->left, res);
        preorderTraversalUtils(root->right, res);
    }
};
```



## 145-Binary Tree Postorder Traversal

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        postorderTraversalUtils(root, res);
        return res;
    }

private:
    void postorderTraversalUtils(TreeNode *root, vector<int> &res) {
        if (root == nullptr)
            return;
        postorderTraversalUtils(root->left, res);
        postorderTraversalUtils(root->right, res);
        res.push_back(root->val);
    }
};
```



## 146-LRU Cache
## 147-Insertion Sort List
## 148-Sort List
## 149-Max Points on a Line
## 150-Evaluate Reverse Polish Notation
## 151-Reverse Words in a String
## 152-Maximum Product Subarray
## 153-Find Minimum in Rotated Sorted Array

保证头大于尾。

```cpp
class Solution {
public:
    int findMin(vector<int> &nums) {
        int res = 0;
        if (nums.empty())
            return res;
        int start = 0;
        int end = nums.size() - 1;
        int mid = start;
        while (nums[start] >= nums[end]) {
            if (end - start == 1)
                return nums[end];
            mid = (start + end) / 2;
            if (nums[start] == nums[end] && nums[start] == nums[mid])
                return minNumInSequence(nums, start, end);
            if (nums[mid] >= nums[start])
                start = mid;
            else if (nums[mid] <= nums[end])
                end = mid;
        }
        return nums[mid];
    }
private:
    int minNumInSequence(vector<int> &nums, int start, int end) {
        int ans = nums[start];
        for (int i = start + 1; i <= end; i++) {
            if (nums[i] < ans)
                ans = nums[i];
        }
        return ans;
    }
};
```



## 154-Find Minimum in Rotated Sorted Array II

当首，中，尾都相等的时候，加入序列查找。

```cpp
class Solution {
public:
    int findMin(vector<int> &nums) {
        int res = 0;
        if (nums.empty())
            return res;
        int start = 0;
        int end = nums.size() - 1;
        int mid = start;
        while (nums[start] >= nums[end]) {
            if (end - start == 1)
                return nums[end];
            mid = (start + end) / 2;
            if (nums[start] == nums[end] && nums[start] == nums[mid])
                return minNumInSequence(nums, start, end);
            if (nums[mid] >= nums[start])
                start = mid;
            else if (nums[mid] <= nums[end])
                end = mid;
        }
        return nums[mid];
    }

private:
    int minNumInSequence(vector<int> &nums, int start, int end) {
        int ans = nums[start];
        for (int i = start + 1; i <= end; i++) {
            if (nums[i] < ans)
                ans = nums[i];
        }
        return ans;
    }
};
```



## 155-Min Stack
## 156-Binary Tree Upside Down
## 157-Read N Characters Given Read4
## 158-Read N Characters Given Read4 II - Call multiple times
## 159-Longest Substring with At Most Two Distinct Characters
## 160-Intersection of Two Linked Lists
## 161-One Edit Distance
## 162-Find Peak Element
## 163-Missing Ranges
## 164-Maximum Gap
## 165-Compare Version Numbers
## 166-Fraction to Recurring Decimal
## 167-Two Sum II - Input array is sorted

利用首位索引找。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int> &numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;
        while (left < right) {
            if (numbers[left] + numbers[right] == target)
                return vector<int>{left + 1, right + 1};
            else if (numbers[left] + numbers[right] > target)
                right--;
            else {
                left++;
            }
        }
        return vector<int>{-1, -1};
    }
};
```



## 168-Excel Sheet Column Title

## 169-Majority Element
## 170-Two Sum III - Data structure design 

按照two sum1遍历，多一个重复数字的处理，如果差值等于遍历的值时，hashset中需要至少有两个以上这个值。

```cpp
Design and implement a TwoSum class. It should support the
following operations: add and find.

add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the value.
  
class TwoSum {
public:
    unordered_multiset<int> nums;

    /**
     * @param number: An integer
     * @return: nothing
     */
    void add(int number) {
        // write your code here
        nums.insert(number);
    }

    /**
     * @param value: An integer
     * @return: Find if there exists any pair of numbers which sum is equal to the value.
     */
    bool find(int value) {
        // write your code here
        for (int num : nums) {
            int count = num == value - num ? 2 : 1;
            if (nums.count(value - num) >= count)
                return true;
        }
        return false;
    }
};
```

## 171-Excel Sheet Column Number
## 172-Factorial Trailing Zeroes
## 173-Binary Search Tree Iterator
## 174-Dungeon Game
## 175-Combine Two Tables
## 176-Second Highest Salary
## 177-Nth Highest Salary
## 178-Rank Scores
## 179-Largest Number
## 180-Consecutive Numbers
## 181-Employees Earning More Than Their Managers
## 182-Duplicate Emails
## 183-Customers Who Never Order
## 184-Department Highest Salary
## 185-Department Top Three Salaries
## 186-Reverse Words in a String II
## 187-Repeated DNA Sequences
## 188-Best Time to Buy and Sell Stock IV

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int> &prices) {
        if (prices.empty())
            return 0;

        int ans = 0;
        if (k >= prices.size() / 2) {
            for (int i = 1; i < prices.size(); ++i) {
                if (prices[i] - prices[i - 1] > 0) {
                    ans += prices[i] - prices[i - 1];
                }
            }
        } else {
            vector<int> local(k + 1);
            vector<int> global(k + 1);
            for (int i = 0; i < prices.size() - 1; ++i) {
                int increase = prices[i + 1] - prices[i];
                for (int j = k; j >= 1; --j) {
                    local[j] = max(global[j - 1] + max(increase, 0), local[j] + increase);
                    global[j] = max(global[j], local[j]);
                }
            }
            ans = global[k];
        }
        return ans;
    }
};
```



## 189-Rotate Array
## 190-Reverse Bits
## 191-Number of 1 Bits
## 192-Word Frequency
## 193-Valid Phone Numbers
## 194-Transpose File
## 195-Tenth Line
## 196-Delete Duplicate Emails
## 197-Rising Temperature
## 198-House Robber
## 199-Binary Tree Right Side View
## 200-Number of Islands
## 201-Bitwise AND of Numbers Range
## 202-Happy Number
## 203-Remove Linked List Elements
## 204-Count Primes
## 205-Isomorphic Strings
## 206-Reverse Linked List
## 207-Course Schedule
## 208-Implement Trie (Prefix Tree)
## 209-Minimum Size Subarray Sum
## 210-Course Schedule II
## 211-Add and Search Word - Data structure design
## 212-Word Search II
## 213-House Robber II
## 214-Shortest Palindrome
## 215-Kth Largest Element in an Array
## 216-Combination Sum III
## 217-Contains Duplicate
## 218-The Skyline Problem
## 219-Contains Duplicate II
## 220-Contains Duplicate III
## 221-Maximal Square
## 222-Count Complete Tree Nodes
## 223-Rectangle Area
## 224-Basic Calculator
## 225-Implement Stack using Queues
## 226-Invert Binary Tree
## 227-Basic Calculator II
## 228-Summary Ranges
## 229-Majority Element II
## 230-Kth Smallest Element in a BST
## 231-Power of Two
## 232-Implement Queue using Stacks
## 233-Number of Digit One
## 234-Palindrome Linked List
## 235-Lowest Common Ancestor of a Binary Search Tree
## 236-Lowest Common Ancestor of a Binary Tree
## 237-Delete Node in a Linked List
## 238-Product of Array Except Self
## 239-Sliding Window Maximum
## 240-Search a 2D Matrix II
## 241-Different Ways to Add Parentheses
## 242-Valid Anagram
## 243-Shortest Word Distance
## 244-Shortest Word Distance II
## 245-Shortest Word Distance III
## 246-Strobogrammatic Number
## 247-Strobogrammatic Number II
## 248-Strobogrammatic Number III
## 249-Group Shifted Strings
## 250-Count Univalue Subtrees
## 251-Flatten 2D Vector
## 252-Meeting Rooms
## 253-Meeting Rooms II
## 254-Factor Combinations
## 255-Verify Preorder Sequence in Binary Search Tree

```cpp
     5
    / \
   2   6
  / \
 1   3
 其先序遍历的结果是 {5, 2, 1, 3, 6}，先设一个最小值 low，然后遍历数组，如果当前值小于这个最小值 low，返回 false，对于根节点，将其压入栈中，然后往后遍历，如果遇到的数字比栈顶元素小，说明是其左子树的点，继续压入栈中，直到遇到的数字比栈顶元素大，那么就是右边的值了，需要找到是哪个节点的右子树，所以更新 low 值并删掉栈顶元素，然后继续和下一个栈顶元素比较，如果还是大于，则继续更新 low 值和删掉栈顶，直到栈为空或者当前栈顶元素大于当前值停止，压入当前值，这样如果遍历完整个数组之前都没有返回 false 的话，最后返回 true 即可，参见代码如下：
       
class Solution {
//
//    Accepted
//            Powered by LintCode FlashJudge
//    100%
//    100% test cases passed Total runtime 50 ms
//            Your submission beats 99.02% Submissions!
public:
    bool verifyPreorder(vector<int> &preorder) {
        int low = INT_MIN;
        stack<int> path;
        for (int p: preorder) {
            if (p < low)
                return false;
            while (!path.empty() && p > path.top()) {
                low = path.top();
                path.pop();
            }
            path.push(p);
        }
        return true;
    }
};
```



## 256-Paint House
## 257-Binary Tree Paths
## 258-Add Digits
## 259-3Sum Smaller

```cpp
Given an array of n integers nums and a target,
find the number of index triplets i, j, k with 0 <= i < j < k < n
that satisfy the condition nums[i] + nums[j] + nums[k] < target.

class Solution {
public:
    int threeSumSmaller(vector<int> &nums, int target) {
        int res = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            int j = i + 1;
            int k = nums.size() - 1;
            while (j < k) {
                int sum3 = nums[i] + nums[j] + nums[k];
                if (sum3 >= target)
                    k--;
                else {
                    res += k - j;
                    j++;
                }
            }
        }
        return res;
    }
};
```



## 260-Single Number III
## 261-Graph Valid Tree
## 262-Trips and Users
## 263-Ugly Number
## 264-Ugly Number II
## 265-Paint House II
## 266-Palindrome Permutation
## 267-Palindrome Permutation II
## 268-Missing Number
## 269-Alien Dictionary
## 270-Closest Binary Search Tree Value
## 271-Encode and Decode Strings
## 272-Closest Binary Search Tree Value II
## 273-Integer to English Words
## 274-H-Index
## 275-H-Index II
## 276-Paint Fence
## 277-Find the Celebrity
## 278-First Bad Version
## 279-Perfect Squares
## 280-Wiggle Sort
## 281-Zigzag Iterator
## 282-Expression Add Operators
## 283-Move Zeroes
## 284-Peeking Iterator
## 285-Inorder Successor in BST
## 286-Walls and Gates
## 287-Find the Duplicate Number
## 288-Unique Word Abbreviation
## 289-Game of Life
## 290-Word Pattern
## 291-Word Pattern II
## 292-Nim Game
## 293-Flip Game
## 294-Flip Game II
## 295-Find Median from Data Stream
## 296-Best Meeting Point
## 297-Serialize and Deserialize Binary Tree
## 298-Binary Tree Longest Consecutive Sequence
## 299-Bulls and Cows
## 300-Longest Increasing Subsequence
## 301-Remove Invalid Parentheses
## 302-Smallest Rectangle Enclosing Black Pixels
## 303-Range Sum Query - Immutable
## 304-Range Sum Query 2D - Immutable
## 305-Number of Islands II
## 306-Additive Number
## 307-Range Sum Query - Mutable
## 308-Range Sum Query 2D - Mutable
## 309-Best Time to Buy and Sell Stock with Cooldown
## 310-Minimum Height Trees
## 311-Sparse Matrix Multiplication
## 312-Burst Balloons
## 313-Super Ugly Number
## 314-Binary Tree Vertical Order Traversal

存入队列的时候，存入节点和它对应的跨度值。用map存储，key为跨度值，值为存储当前跨度值的vector。

```cpp
class Solution {
//    100% test cases passedTotal runtime 14 ms
//    Your submission beats 83.00% Submissions!
public:
    vector<vector<int>> verticalOrder(TreeNode *root) {
        vector<vector<int>> res;
        if (!root)
            return res;

        queue<pair<TreeNode *, int>> q;
        map<int, vector<int>> m;
        map<int, vector<int>>::iterator itr;
        q.push({root, 0});
        while (!q.empty()) {
//            vector<int> level;
            pair<TreeNode *, int> curr = q.front();
            m[curr.second].push_back(curr.first->val);
            q.pop();
            if (curr.first->left)
                q.push({curr.first->left, curr.second - 1});
            if (curr.first->right)
                q.push({curr.first->right, curr.second + 1});
        }
        for (itr = m.begin(); itr != m.end(); itr++) {
            res.push_back(itr->second);
        }
        return res;
    }
};
```



## 315-Count of Smaller Numbers After Self
## 316-Remove Duplicate Letters
## 317-Shortest Distance from All Buildings
## 318-Maximum Product of Word Lengths
## 319-Bulb Switcher
## 320-Generalized Abbreviation
## 321-Create Maximum Number
## 322-Coin Change
## 323-Number of Connected Components in an Undirected Graph
## 324-Wiggle Sort II
## 325-Maximum Size Subarray Sum Equals k
## 326-Power of Three
## 327-Count of Range Sum
## 328-Odd Even Linked List
## 329-Longest Increasing Path in a Matrix
## 330-Patching Array
## 331-Verify Preorder Serialization of a Binary Tree
## 332-Reconstruct Itinerary
## 333-Largest BST Subtree
## 334-Increasing Triplet Subsequence
## 335-Self Crossing
## 336-Palindrome Pairs
## 337-House Robber III
## 338-Counting Bits
## 339-Nested List Weight Sum
## 340-Longest Substring with At Most K Distinct Characters
## 341-Flatten Nested List Iterator
## 342-Power of Four
## 343-Integer Break
## 344-Reverse String
## 345-Reverse Vowels of a String
## 346-Moving Average from Data Stream
## 347-Top K Frequent Elements
## 348-Design Tic-Tac-Toe
## 349-Intersection of Two Arrays
## 350-Intersection of Two Arrays II
## 351-Android Unlock Patterns
## 352-Data Stream as Disjoint Intervals
## 353-Design Snake Game
## 354-Russian Doll Envelopes
## 355-Design Twitter
## 356-Line Reflection
## 357-Count Numbers with Unique Digits
## 358-Rearrange String k Distance Apart
## 359-Logger Rate Limiter
## 360-Sort Transformed Array
## 361-Bomb Enemy
## 362-Design Hit Counter
## 363-Max Sum of Rectangle No Larger Than K
## 364-Nested List Weight Sum II
## 365-Water and Jug Problem
## 366-Find Leaves of Binary Tree
## 367-Valid Perfect Square
## 368-Largest Divisible Subset
## 369-Plus One Linked List
## 370-Range Addition
## 371-Sum of Two Integers
## 372-Super Pow
## 373-Find K Pairs with Smallest Sums
## 374-Guess Number Higher or Lower
## 375-Guess Number Higher or Lower II
## 376-Wiggle Subsequence
## 377-Combination Sum IV
## 378-Kth Smallest Element in a Sorted Matrix
## 379-Design Phone Directory
## 380-Insert Delete GetRandom O(1)
## 381-Insert Delete GetRandom O(1) - Duplicates allowed
## 382-Linked List Random Node
## 383-Ransom Note
## 384-Shuffle an Array
## 385-Mini Parser
## 386-Lexicographical Numbers
## 387-First Unique Character in a String
## 388-Longest Absolute File Path
## 389-Find the Difference
## 390-Elimination Game
## 391-Perfect Rectangle
## 392-Is Subsequence
## 393-UTF-8 Validation
## 394-Decode String
## 395-Longest Substring with At Least K Repeating Characters
## 396-Rotate Function
## 397-Integer Replacement
## 398-Random Pick Index
## 399-Evaluate Division
## 400-Nth Digit
## 401-Binary Watch
## 402-Remove K Digits
## 403-Frog Jump
## 404-Sum of Left Leaves
## 405-Convert a Number to Hexadecimal
## 406-Queue Reconstruction by Height
## 407-Trapping Rain Water II
## 408-Valid Word Abbreviation
## 409-Longest Palindrome
## 410-Split Array Largest Sum
## 411-Minimum Unique Word Abbreviation
## 412-Fizz Buzz
## 413-Arithmetic Slices
## 414-Third Maximum Number
## 415-Add Strings
## 416-Partition Equal Subset Sum
## 417-Pacific Atlantic Water Flow
## 418-Sentence Screen Fitting
## 419-Battleships in a Board
## 420-Strong Password Checker
## 421-Maximum XOR of Two Numbers in an Array
## 422-Valid Word Square
## 423-Reconstruct Original Digits from English
## 424-Longest Repeating Character Replacement
## 425-Word Squares
## 426-Convert Binary Search Tree to Sorted Doubly Linked List
## 427-Construct Quad Tree
## 428-Serialize and Deserialize N-ary Tree
## 429-N-ary Tree Level Order Traversal
## 430-Flatten a Multilevel Doubly Linked List
## 431-Encode N-ary Tree to Binary Tree
## 432-All O`one Data Structure
## 433-Minimum Genetic Mutation
## 434-Number of Segments in a String
## 435-Non-overlapping Intervals
## 436-Find Right Interval
## 437-Path Sum III
## 438-Find All Anagrams in a String
## 439-Ternary Expression Parser
## 440-K-th Smallest in Lexicographical Order
## 441-Arranging Coins
## 442-Find All Duplicates in an Array
## 443-String Compression
## 444-Sequence Reconstruction
## 445-Add Two Numbers II

使用栈先取链表值，然后遍历栈，每次都新建头结点，最后检查头结点是否为0.

```cpp
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
  class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        stack<int> s1, s2;
        while (l1) {
            s1.push(l1->val);
            l1 = l1->next;
        }
        while (l2) {
            s2.push(l2->val);
            l2 = l2->next;
        }

        ListNode *res = new ListNode(0);
        int sum = 0;
        while (!s1.empty() || !s2.empty()) {
            if (!s1.empty()) {
                sum += s1.top();
                s1.pop();
            }
            if (!s2.empty()) {
                sum += s2.top();
                s2.pop();
            }
            res->val = sum % 10;
            ListNode *head = new ListNode(sum / 10);
            head->next = res;
            res = head;
            sum = sum / 10;
        }
        return res->val == 0 ? res->next : res;
    }
};
```

## 446-Arithmetic Slices II - Subsequence
## 447-Number of Boomerangs
## 448-Find All Numbers Disappeared in an Array
## 449-Serialize and Deserialize BST
## 450-Delete Node in a BST
## 451-Sort Characters By Frequency
## 452-Minimum Number of Arrows to Burst Balloons
## 453-Minimum Moves to Equal Array Elements
## 454-4Sum II
## 455-Assign Cookies
## 456-132 Pattern
## 457-Circular Array Loop
## 458-Poor Pigs
## 459-Repeated Substring Pattern
## 460-LFU Cache
## 461-Hamming Distance
## 462-Minimum Moves to Equal Array Elements II
## 463-Island Perimeter
## 464-Can I Win
## 465-Optimal Account Balancing
## 466-Count The Repetitions
## 467-Unique Substrings in Wraparound String
## 468-Validate IP Address
## 469-Convex Polygon
## 470-Implement Rand10() Using Rand7()
## 471-Encode String with Shortest Length
## 472-Concatenated Words
## 473-Matchsticks to Square
## 474-Ones and Zeroes
## 475-Heaters
## 476-Number Complement
## 477-Total Hamming Distance
## 478-Generate Random Point in a Circle
## 479-Largest Palindrome Product
## 480-Sliding Window Median
## 481-Magical String
## 482-License Key Formatting
## 483-Smallest Good Base
## 484-Find Permutation
## 485-Max Consecutive Ones
## 486-Predict the Winner
## 487-Max Consecutive Ones II
## 488-Zuma Game
## 489-Robot Room Cleaner
## 490-The Maze
## 491-Increasing Subsequences
## 492-Construct the Rectangle
## 493-Reverse Pairs
## 494-Target Sum
## 495-Teemo Attacking
## 496-Next Greater Element I
## 497-Random Point in Non-overlapping Rectangles
## 498-Diagonal Traverse
## 499-The Maze III
## 500-Keyboard Row
## 501-Find Mode in Binary Search Tree
## 502-IPO
## 503-Next Greater Element II
## 504-Base 7
## 505-The Maze II
## 506-Relative Ranks
## 507-Perfect Number
## 508-Most Frequent Subtree Sum
## 509-Fibonacci Number
## 510-Inorder Successor in BST II
## 511-Game Play Analysis I
## 512-Game Play Analysis II
## 513-Find Bottom Left Tree Value
## 514-Freedom Trail
## 515-Find Largest Value in Each Tree Row
## 516-Longest Palindromic Subsequence

先记录1个字符，2个字符的回文长度，然后记录间隔3个以上的字符回文情况。

```cpp
约束条件为：
table[i][j] = table[i + 1][j - 1] + 2;
table[i][j] = max(table[i + 1][j], table[i][j - 1]);
class Solution {
public:
    int longestPalindromeSubseq(string &s) {
        int length = s.size();
        int table[length][length];
        for (int i = 0; i < length; i++) {
            table[i][i] = 1;
        }
        for (int k = 2; k <= length; k++) {
            for (int i = 0; i < length - k + 1; i++) {
                int j = i + k - 1;
                if (s[i] == s[j] && k == 2) {
                    table[i][j] = 2;
                } else if (s[i] == s[j]) {
                    table[i][j] = table[i + 1][j - 1] + 2;
                } else {
                    table[i][j] = max(table[i + 1][j], table[i][j - 1]);
                }
            }
        }
        return table[0][length-1];
    }
};
```



## 517-Super Washing Machines
## 518-Coin Change 2
## 519-Random Flip Matrix
## 520-Detect Capital
## 521-Longest Uncommon Subsequence I
## 522-Longest Uncommon Subsequence II
## 523-Continuous Subarray Sum
## 524-Longest Word in Dictionary through Deleting
## 525-Contiguous Array
## 526-Beautiful Arrangement
## 527-Word Abbreviation
## 528-Random Pick with Weight
## 529-Minesweeper
## 530-Minimum Absolute Difference in BST
## 531-Lonely Pixel I
## 532-K-diff Pairs in an Array
## 533-Lonely Pixel II
## 534-Game Play Analysis III
## 535-Encode and Decode TinyURL
## 536-Construct Binary Tree from String
## 537-Complex Number Multiplication
## 538-Convert BST to Greater Tree
## 539-Minimum Time Difference
## 540-Single Element in a Sorted Array
## 541-Reverse String II
## 542-01 Matrix
## 543-Diameter of Binary Tree
## 544-Output Contest Matches
## 545-Boundary of Binary Tree
## 546-Remove Boxes
## 547-Friend Circles
## 548-Split Array with Equal Sum
## 549-Binary Tree Longest Consecutive Sequence II
## 550-Game Play Analysis IV
## 551-Student Attendance Record I
## 552-Student Attendance Record II
## 553-Optimal Division
## 554-Brick Wall
## 555-Split Concatenated Strings
## 556-Next Greater Element III
## 557-Reverse Words in a String III
## 558-Quad Tree Intersection
## 559-Maximum Depth of N-ary Tree
## 560-Subarray Sum Equals K
## 561-Array Partition I
## 562-Longest Line of Consecutive One in Matrix
## 563-Binary Tree Tilt
## 564-Find the Closest Palindrome
## 565-Array Nesting
## 566-Reshape the Matrix
## 567-Permutation in String
## 568-Maximum Vacation Days
## 569-Median Employee Salary
## 570-Managers with at Least 5 Direct Reports
## 571-Find Median Given Frequency of Numbers
## 572-Subtree of Another Tree
## 573-Squirrel Simulation
## 574-Winning Candidate
## 575-Distribute Candies
## 576-Out of Boundary Paths
## 577-Employee Bonus
## 578-Get Highest Answer Rate Question
## 579-Find Cumulative Salary of an Employee
## 580-Count Student Number in Departments
## 581-Shortest Unsorted Continuous Subarray
## 582-Kill Process
## 583-Delete Operation for Two Strings
## 584-Find Customer Referee
## 585-Investments in 2016
## 586-Customer Placing the Largest Number of Orders
## 587-Erect the Fence
## 588-Design In-Memory File System
## 589-N-ary Tree Preorder Traversal
## 590-N-ary Tree Postorder Traversal
## 591-Tag Validator
## 592-Fraction Addition and Subtraction
## 593-Valid Square
## 594-Longest Harmonious Subsequence
## 595-Big Countries
## 596-Classes More Than 5 Students
## 597-Friend Requests I: Overall Acceptance Rate
## 598-Range Addition II
## 599-Minimum Index Sum of Two Lists
## 600-Non-negative Integers without Consecutive Ones
## 601-Human Traffic of Stadium
## 602-Friend Requests II: Who Has the Most Friends
## 603-Consecutive Available Seats
## 604-Design Compressed String Iterator
## 605-Can Place Flowers
## 606-Construct String from Binary Tree
## 607-Sales Person
## 608-Tree Node
## 609-Find Duplicate File in System
## 610-Triangle Judgement
## 611-Valid Triangle Number
## 612-Shortest Distance in a Plane
## 613-Shortest Distance in a Line
## 614-Second Degree Follower
## 615-Average Salary: Departments VS Company
## 616-Add Bold Tag in String
## 617-Merge Two Binary Trees
## 618-Students Report By Geography
## 619-Biggest Single Number
## 620-Not Boring Movies
## 621-Task Scheduler
## 622-Design Circular Queue
## 623-Add One Row to Tree
## 624-Maximum Distance in Arrays
## 625-Minimum Factorization
## 626-Exchange Seats
## 627-Swap Salary
## 628-Maximum Product of Three Numbers
## 629-K Inverse Pairs Array
## 630-Course Schedule III
## 631-Design Excel Sum Formula
## 632-Smallest Range
## 633-Sum of Square Numbers
## 634-Find the Derangement of An Array
## 635-Design Log Storage System
## 636-Exclusive Time of Functions
## 637-Average of Levels in Binary Tree
## 638-Shopping Offers
## 639-Decode Ways II
## 640-Solve the Equation
## 641-Design Circular Deque
## 642-Design Search Autocomplete System
## 643-Maximum Average Subarray I
## 644-Maximum Average Subarray II
## 645-Set Mismatch
## 646-Maximum Length of Pair Chain
## 647-Palindromic Substrings
## 648-Replace Words
## 649-Dota2 Senate
## 650-2 Keys Keyboard
## 651-4 Keys Keyboard
## 652-Find Duplicate Subtrees
## 653-Two Sum IV - Input is a BST

先中序遍历存放到vector里边，然后执行two sum2.

## 654-Maximum Binary Tree
## 655-Print Binary Tree
## 656-Coin Path
## 657-Robot Return to Origin
## 658-Find K Closest Elements
## 659-Split Array into Consecutive Subsequences
## 660-Remove 9
## 661-Image Smoother
## 662-Maximum Width of Binary Tree
## 663-Equal Tree Partition
## 664-Strange Printer
## 665-Non-decreasing Array
## 666-Path Sum IV
## 667-Beautiful Arrangement II
## 668-Kth Smallest Number in Multiplication Table
## 669-Trim a Binary Search Tree
## 670-Maximum Swap
## 671-Second Minimum Node In a Binary Tree
## 672-Bulb Switcher II
## 673-Number of Longest Increasing Subsequence
## 674-Longest Continuous Increasing Subsequence
## 675-Cut Off Trees for Golf Event
## 676-Implement Magic Dictionary
## 677-Map Sum Pairs
## 678-Valid Parenthesis String
## 679-24 Game
## 680-Valid Palindrome II
## 681-Next Closest Time
## 682-Baseball Game
## 683-K Empty Slots
## 684-Redundant Connection
## 685-Redundant Connection II
## 686-Repeated String Match
## 687-Longest Univalue Path
## 688-Knight Probability in Chessboard
## 689-Maximum Sum of 3 Non-Overlapping Subarrays
## 690-Employee Importance
## 691-Stickers to Spell Word
## 692-Top K Frequent Words
## 693-Binary Number with Alternating Bits
## 694-Number of Distinct Islands
## 695-Max Area of Island
## 696-Count Binary Substrings
## 697-Degree of an Array
## 698-Partition to K Equal Sum Subsets
## 699-Falling Squares
## 700-Search in a Binary Search Tree
## 701-Insert into a Binary Search Tree
## 702-Search in a Sorted Array of Unknown Size
## 703-Kth Largest Element in a Stream
## 704-Binary Search
## 705-Design HashSet
## 706-Design HashMap
## 707-Design Linked List
## 708-Insert into a Cyclic Sorted List
## 709-To Lower Case
## 710-Random Pick with Blacklist
## 711-Number of Distinct Islands II
## 712-Minimum ASCII Delete Sum for Two Strings
## 713-Subarray Product Less Than K
## 714-Best Time to Buy and Sell Stock with Transaction Fee
## 715-Range Module
## 716-Max Stack
## 717-1-bit and 2-bit Characters
## 718-Maximum Length of Repeated Subarray
## 719-Find K-th Smallest Pair Distance
## 720-Longest Word in Dictionary
## 721-Accounts Merge
## 722-Remove Comments
## 723-Candy Crush
## 724-Find Pivot Index
## 725-Split Linked List in Parts
## 726-Number of Atoms
## 727-Minimum Window Subsequence
## 728-Self Dividing Numbers
## 729-My Calendar I
## 730-Count Different Palindromic Subsequences
## 731-My Calendar II
## 732-My Calendar III
## 733-Flood Fill
## 734-Sentence Similarity
## 735-Asteroid Collision
## 736-Parse Lisp Expression
## 737-Sentence Similarity II
## 738-Monotone Increasing Digits
## 739-Daily Temperatures
## 740-Delete and Earn
## 741-Cherry Pickup
## 742-Closest Leaf in a Binary Tree
## 743-Network Delay Time
## 744-Find Smallest Letter Greater Than Target
## 745-Prefix and Suffix Search
## 746-Min Cost Climbing Stairs
## 747-Largest Number At Least Twice of Others
## 748-Shortest Completing Word
## 749-Contain Virus
## 750-Number Of Corner Rectangles
## 751-IP to CIDR
## 752-Open the Lock
## 753-Cracking the Safe
## 754-Reach a Number
## 755-Pour Water
## 756-Pyramid Transition Matrix
## 757-Set Intersection Size At Least Two
## 758-Bold Words in String
## 759-Employee Free Time
## 760-Find Anagram Mappings
## 761-Special Binary String
## 762-Prime Number of Set Bits in Binary Representation
## 763-Partition Labels
## 764-Largest Plus Sign
## 765-Couples Holding Hands
## 766-Toeplitz Matrix
## 767-Reorganize String
## 768-Max Chunks To Make Sorted II
## 769-Max Chunks To Make Sorted
## 770-Basic Calculator IV
## 771-Jewels and Stones
## 772-Basic Calculator III
## 773-Sliding Puzzle
## 774-Minimize Max Distance to Gas Station
## 775-Global and Local Inversions
## 776-Split BST
## 777-Swap Adjacent in LR String
## 778-Swim in Rising Water
## 779-K-th Symbol in Grammar
## 780-Reaching Points
## 781-Rabbits in Forest
## 782-Transform to Chessboard
## 783-Minimum Distance Between BST Nodes
## 784-Letter Case Permutation
## 785-Is Graph Bipartite?
## 786-K-th Smallest Prime Fraction
## 787-Cheapest Flights Within K Stops
## 788-Rotated Digits
## 789-Escape The Ghosts
## 790-Domino and Tromino Tiling
## 791-Custom Sort String
## 792-Number of Matching Subsequences
## 793-Preimage Size of Factorial Zeroes Function
## 794-Valid Tic-Tac-Toe State
## 795-Number of Subarrays with Bounded Maximum
## 796-Rotate String
## 797-All Paths From Source to Target
## 798-Smallest Rotation with Highest Score
## 799-Champagne Tower
## 800-Similar RGB Color
## 801-Minimum Swaps To Make Sequences Increasing
## 802-Find Eventual Safe States
## 803-Bricks Falling When Hit
## 804-Unique Morse Code Words
## 805-Split Array With Same Average
## 806-Number of Lines To Write String
## 807-Max Increase to Keep City Skyline
## 808-Soup Servings
## 809-Expressive Words
## 810-Chalkboard XOR Game
## 811-Subdomain Visit Count
## 812-Largest Triangle Area
## 813-Largest Sum of Averages
## 814-Binary Tree Pruning
## 815-Bus Routes
## 816-Ambiguous Coordinates
## 817-Linked List Components
## 818-Race Car
## 819-Most Common Word
## 820-Short Encoding of Words
## 821-Shortest Distance to a Character
## 822-Card Flipping Game
## 823-Binary Trees With Factors
## 824-Goat Latin
## 825-Friends Of Appropriate Ages
## 826-Most Profit Assigning Work
## 827-Making A Large Island
## 828-Unique Letter String
## 829-Consecutive Numbers Sum
## 830-Positions of Large Groups
## 831-Masking Personal Information
## 832-Flipping an Image
## 833-Find And Replace in String
## 834-Sum of Distances in Tree
## 835-Image Overlap
## 836-Rectangle Overlap
## 837-New 21 Game
## 838-Push Dominoes
## 839-Similar String Groups
## 840-Magic Squares In Grid
## 841-Keys and Rooms
## 842-Split Array into Fibonacci Sequence
## 843-Guess the Word
## 844-Backspace String Compare
## 845-Longest Mountain in Array
## 846-Hand of Straights
## 847-Shortest Path Visiting All Nodes
## 848-Shifting Letters
## 849-Maximize Distance to Closest Person
## 850-Rectangle Area II
## 851-Loud and Rich
## 852-Peak Index in a Mountain Array
## 853-Car Fleet
## 854-K-Similar Strings
## 855-Exam Room
## 856-Score of Parentheses
## 857-Minimum Cost to Hire K Workers
## 858-Mirror Reflection
## 859-Buddy Strings
## 860-Lemonade Change
## 861-Score After Flipping Matrix
## 862-Shortest Subarray with Sum at Least K
## 863-All Nodes Distance K in Binary Tree
## 864-Shortest Path to Get All Keys
## 865-Smallest Subtree with all the Deepest Nodes
## 866-Prime Palindrome
## 867-Transpose Matrix
## 868-Binary Gap
## 869-Reordered Power of 2
## 870-Advantage Shuffle
## 871-Minimum Number of Refueling Stops
## 872-Leaf-Similar Trees
## 873-Length of Longest Fibonacci Subsequence
## 874-Walking Robot Simulation
## 875-Koko Eating Bananas
## 876-Middle of the Linked List
## 877-Stone Game
## 878-Nth Magical Number
## 879-Profitable Schemes
## 880-Decoded String at Index
## 881-Boats to Save People
## 882-Reachable Nodes In Subdivided Graph
## 883-Projection Area of 3D Shapes
## 884-Uncommon Words from Two Sentences
## 885-Spiral Matrix III
## 886-Possible Bipartition
## 887-Super Egg Drop
## 888-Fair Candy Swap
## 889-Construct Binary Tree from Preorder and Postorder Traversal
## 890-Find and Replace Pattern
## 891-Sum of Subsequence Widths
## 892-Surface Area of 3D Shapes
## 893-Groups of Special-Equivalent Strings
## 894-All Possible Full Binary Trees
## 895-Maximum Frequency Stack
## 896-Monotonic Array
## 897-Increasing Order Search Tree
## 898-Bitwise ORs of Subarrays
## 899-Orderly Queue
## 900-RLE Iterator
## 901-Online Stock Span
## 902-Numbers At Most N Given Digit Set
## 903-Valid Permutations for DI Sequence
## 904-Fruit Into Baskets
## 905-Sort Array By Parity
## 906-Super Palindromes
## 907-Sum of Subarray Minimums
## 908-Smallest Range I
## 909-Snakes and Ladders
## 910-Smallest Range II
## 911-Online Election
## 912-Sort an Array
## 913-Cat and Mouse
## 914-X of a Kind in a Deck of Cards
## 915-Partition Array into Disjoint Intervals
## 916-Word Subsets
## 917-Reverse Only Letters
## 918-Maximum Sum Circular Subarray
## 919-Complete Binary Tree Inserter
## 920-Number of Music Playlists
## 921-Minimum Add to Make Parentheses Valid
## 922-Sort Array By Parity II
## 923-3Sum With Multiplicity
## 924-Minimize Malware Spread
## 925-Long Pressed Name
## 926-Flip String to Monotone Increasing
## 927-Three Equal Parts
## 928-Minimize Malware Spread II
## 929-Unique Email Addresses
## 930-Binary Subarrays With Sum
## 931-Minimum Falling Path Sum
## 932-Beautiful Array
## 933-Number of Recent Calls
## 934-Shortest Bridge
## 935-Knight Dialer
## 936-Stamping The Sequence
## 937-Reorder Log Files
## 938-Range Sum of BST
## 939-Minimum Area Rectangle
## 940-Distinct Subsequences II
## 941-Valid Mountain Array
## 942-DI String Match
## 943-Find the Shortest Superstring
## 944-Delete Columns to Make Sorted
## 945-Minimum Increment to Make Array Unique
## 946-Validate Stack Sequences
## 947-Most Stones Removed with Same Row or Column
## 948-Bag of Tokens
## 949-Largest Time for Given Digits
## 950-Reveal Cards In Increasing Order
## 951-Flip Equivalent Binary Trees
## 952-Largest Component Size by Common Factor
## 953-Verifying an Alien Dictionary
## 954-Array of Doubled Pairs
## 955-Delete Columns to Make Sorted II
## 956-Tallest Billboard
## 957-Prison Cells After N Days
## 958-Check Completeness of a Binary Tree
## 959-Regions Cut By Slashes
## 960-Delete Columns to Make Sorted III
## 961-N-Repeated Element in Size 2N Array
## 962-Maximum Width Ramp
## 963-Minimum Area Rectangle II
## 964-Least Operators to Express Number
## 965-Univalued Binary Tree
## 966-Vowel Spellchecker
## 967-Numbers With Same Consecutive Differences
## 968-Binary Tree Cameras
## 969-Pancake Sorting
## 970-Powerful Integers
## 971-Flip Binary Tree To Match Preorder Traversal
## 972-Equal Rational Numbers
## 973-K Closest Points to Origin
## 974-Subarray Sums Divisible by K
## 975-Odd Even Jump
## 976-Largest Perimeter Triangle
## 977-Squares of a Sorted Array
## 978-Longest Turbulent Subarray
## 979-Distribute Coins in Binary Tree
## 980-Unique Paths III
## 981-Time Based Key-Value Store
## 982-Triples with Bitwise AND Equal To Zero
## 983-Minimum Cost For Tickets
## 984-String Without AAA or BBB
## 985-Sum of Even Numbers After Queries
## 986-Interval List Intersections
## 987-Vertical Order Traversal of a Binary Tree
## 988-Smallest String Starting From Leaf
## 989-Add to Array-Form of Integer
## 990-Satisfiability of Equality Equations
## 991-Broken Calculator
## 992-Subarrays with K Different Integers
## 993-Cousins in Binary Tree

存入队列的时候，存入节点和它对应的跨度值。用map存储，key为level值，值为存储当前跨度值的vector。

```cpp
class Solution {
//    wrong code
//    v1 depth[root->val] = (parNode == nullptr ? 1 : depth[root->val] + 1);
//    v2 depth[root->val] = (parNode == nullptr ? 0 : depth[root->val] + 1);

public:
    bool isCousins(TreeNode *root, int x, int y) {
        map<int, TreeNode *> par;
        map<int, int> depth;
        if (!root)
            return false;
        helper(root, nullptr, par, depth);
        return (par[x] != par[y]) && (depth[x] == depth[y]);
    }

private:
    void helper(TreeNode *root, TreeNode *parNode, map<int, TreeNode *> &par, map<int, int> &depth) {
        if (!root)
            return;
        par[root->val] = parNode;
        depth[root->val] = (parNode == nullptr ? 0 : depth[parNode->val] + 1);
        helper(root->left, root, par, depth);
        helper(root->right, root, par, depth);
    }
};
```



## 994-Rotting Oranges
## 995-Minimum Number of K Consecutive Bit Flips
## 996-Number of Squareful Arrays
## 997-Find the Town Judge
## 998-Maximum Binary Tree II
## 999-Available Captures for Rook
## 1000-Minimum Cost to Merge Stones
## 1001-Grid Illumination
## 1002-Find Common Characters
## 1003-Check If Word Is Valid After Substitutions
## 1004-Max Consecutive Ones III
## 1005-Maximize Sum Of Array After K Negations
## 1006-Clumsy Factorial
## 1007-Minimum Domino Rotations For Equal Row
## 1008-Construct Binary Search Tree from Preorder Traversal
## 1009-Complement of Base 10 Integer
## 1010-Pairs of Songs With Total Durations Divisible by 60
## 1011-Capacity To Ship Packages Within D Days
## 1012-Numbers With Repeated Digits
## 1013-Partition Array Into Three Parts With Equal Sum
## 1014-Best Sightseeing Pair
## 1015-Smallest Integer Divisible by K
## 1016-Binary String With Substrings Representing 1 To N
## 1017-Convert to Base -2
## 1018-Binary Prefix Divisible By 5
## 1019-Next Greater Node In Linked List
## 1020-Number of Enclaves
## 1021-Remove Outermost Parentheses
## 1022-Sum of Root To Leaf Binary Numbers
## 1023-Camelcase Matching
## 1024-Video Stitching
## 1025-Divisor Game
## 1026-Maximum Difference Between Node and Ancestor
## 1027-Longest Arithmetic Sequence
## 1028-Recover a Tree From Preorder Traversal
## 1029-Two City Scheduling
## 1030-Matrix Cells in Distance Order
## 1031-Maximum Sum of Two Non-Overlapping Subarrays
## 1032-Stream of Characters
## 1033-Moving Stones Until Consecutive
## 1034-Coloring A Border
## 1035-Uncrossed Lines
## 1036-Escape a Large Maze
## 1037-Valid Boomerang
## 1038-Binary Search Tree to Greater Sum Tree
## 1039-Minimum Score Triangulation of Polygon
## 1040-Moving Stones Until Consecutive II
## 1041-Robot Bounded In Circle
## 1042-Flower Planting With No Adjacent
## 1043-Partition Array for Maximum Sum
## 1044-Longest Duplicate Substring
## 1045-Customers Who Bought All Products
## 1046-Last Stone Weight
## 1047-Remove All Adjacent Duplicates In String
## 1048-Longest String Chain
## 1049-Last Stone Weight II
## 1050-Actors and Directors Who Cooperated At Least Three Times
## 1051-Height Checker
## 1052-Grumpy Bookstore Owner
## 1053-Previous Permutation With One Swap
## 1054-Distant Barcodes
## 1055-Shortest Way to Form String
## 1056-Confusing Number
## 1057-Campus Bikes
## 1058-Minimize Rounding Error to Meet Target
## 1059-All Paths from Source Lead to Destination
## 1060-Missing Element in Sorted Array
## 1061-Lexicographically Smallest Equivalent String
## 1062-Longest Repeating Substring
## 1063-Number of Valid Subarrays
## 1064-Fixed Point
## 1065-Index Pairs of a String
## 1066-Campus Bikes II
## 1067-Digit Count in Range
## 1068-Product Sales Analysis I
## 1069-Product Sales Analysis II
## 1070-Product Sales Analysis III
## 1071-Greatest Common Divisor of Strings
## 1072-Flip Columns For Maximum Number of Equal Rows
## 1073-Adding Two Negabinary Numbers
## 1074-Number of Submatrices That Sum to Target
## 1075-Project Employees I
## 1076-Project Employees II
## 1077-Project Employees III
## 1078-Occurrences After Bigram
## 1079-Letter Tile Possibilities
## 1080-Insufficient Nodes in Root to Leaf Paths
## 1081-Smallest Subsequence of Distinct Characters
## 1082-Sales Analysis I
## 1083-Sales Analysis II
## 1084-Sales Analysis III
## 1085-Sum of Digits in the Minimum Number
## 1086-High Five
## 1087-Brace Expansion
## 1088-Confusing Number II
## 1089-Duplicate Zeros
## 1090-Largest Values From Labels
## 1091-Shortest Path in Binary Matrix
## 1092-Shortest Common Supersequence
## 1093-Statistics from a Large Sample
## 1094-Car Pooling
## 1095-Find in Mountain Array
## 1096-Brace Expansion II
## 1097-Game Play Analysis V
## 1098-Unpopular Books
## 1099-Two Sum Less Than K

将数组排序，根据首位索引缩小查找范围，利用max函数维护最大值。

```cpp
class Solution {
public:
    int twoSumLessThanK(vector<int> &vect, int k) {
        sort(begin(vect), end(vect));
        int res = -1;
        int start = 0;
        int end = vect.size() - 1;
        while (start < end) {
            if (vect[start] + vect[end] > k)
                end--;
            else {
                res = max(res, vect[start] + vect[end]);
                start++;
            }
        }
        return res;
    }
};
```



## 1100-Find K-Length Substrings With No Repeated Characters
## 1101-The Earliest Moment When Everyone Become Friends
## 1102-Path With Maximum Minimum Value
## 1103-Distribute Candies to People
## 1104-Path In Zigzag Labelled Binary Tree
## 1105-Filling Bookcase Shelves
## 1106-Parsing A Boolean Expression
## 1107-New Users Daily Count
## 1108-Defanging an IP Address
## 1109-Corporate Flight Bookings
## 1110-Delete Nodes And Return Forest
## 1111-Maximum Nesting Depth of Two Valid Parentheses Strings
## 1112-Highest Grade For Each Student
## 1113-Reported Posts
## 1114-Print in Order New
## 1115-Print FooBar Alternately New
## 1116-Print Zero Even Odd New
## 1117-Building H2O New
## 1118-Number of Days in a Month
## 1119-Remove Vowels from a String
## 1120-Maximum Average Subtree
## 1121-Divide Array Into Increasing Sequences
## 1122-Relative Sort Array New
## 1123-Lowest Common Ancestor of Deepest Leaves New
## 1124-Longest Well-Performing Interval New
## 1125-Smallest Sufficient Team New
## 1126-Active Businesses New
## 1127-User Purchase Platform New